<!DOCTYPE html>
<html>
<head>
    <!-- MathJax for mathematical notation -->
    <script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$']],
            displayMath: [['$$', '$$']],
            processEscapes: true
        },
        svg: {
            fontCache: 'global'
        }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    
    <!-- Pyodide and CodeMirror -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/theme/pastel-on-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/python/python.min.js"></script>
    
    <!-- Favicons -->
    <link rel="icon" type="image/x-icon" href="../assets/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="../assets/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../assets/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="192x192" href="../assets/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="../assets/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="../assets/android-chrome-512x512.png">
    
    <!-- Core Stylesheets -->
    <link rel="stylesheet" href=../assets/colours-l2d.css>
    <link rel="stylesheet" href="../assets/shared-styles.css">
    <link rel="stylesheet" href="../assets/nav-bar.css">
    <link rel="stylesheet" href="../assets/module_card.css">
    <link rel="stylesheet" href="../assets/learning_outcomes.css">
    <link rel="stylesheet" href="../assets/learning_lists.css">
    <link rel="stylesheet" href="../assets/box_styles.css">
    <link rel="stylesheet" href="../assets/code_styles.css">

    <!-- Meta Tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L2D - DH4 - Visualisation</title>
    
    <!-- File URLs for this lesson -->
    <script>
        window.LESSON_FILES = [
            {url: "https://raw.githubusercontent.com/ScryptIQ-ai/lesson-data/refs/heads/main/dh/EEG_absence.txt", filename: "EEG_absence.txt", is_binary: false},
            {url: "https://raw.githubusercontent.com/ScryptIQ-ai/lesson-data/refs/heads/main/dh/EEG_background.txt", filename: "EEG_background.txt", is_binary: false}
        ];
        window.LESSON_PACKAGES = ['pandas', 'matplotlib', 'numpy'];
    </script>
        
</head>
<body>
    
    <!-- Sidebar Navigation -->
    <div id="sidebar" class="sidebar">
        <div class="sidebar-header">
            <a href="../homepage.html" style="text-decoration: none; display: inline-block;">
                <img src="../assets/l2d-brain-logo.png" alt="scryptIQ Logo" class="sidebar-logo">
            </a>
        </div>

        <h3>Content</h3>
        <ul>
            <li><a href="./introduction.html" class="">Introduction</a></li>
            <li>
                <div class="nav-toggle active" data-target="expandable-section-1">
                    Visualisation
                    <span class="toggle-icon">▼</span>
                </div>
                <ul class="nested-nav expanded" id="expandable-section-1"><li><a href="#introduction">Introduction</a></li><li><a href="#the-plotting-function">The Plotting Function</a></li><li><a href="#normal-and-pathological-eeg">Normal and Pathological EEG</a></li><li><a href="#display-data-with-offset">Display data with offset</a></li><li><a href="#summary">Summary</a></li>
                </ul>
            </li><li><a href="./filtering.html">Filtering</a></li><li><a href="./analysing.html">Analysis</a></li><li><a href="./assignment.html">Assignment</a></li><li><a href="./feedback.html">Feedback</a></li>
        </ul>

        <h3 class="collapsible-header collapsed">
            Resources
            <span class="collapse-icon">►</span>
        </h3>
        <div class="collapsible-content collapsed">
            <ul>
                <li><a href="./glossary.html">Glossary</a></li><li><a href="./downloads.html">Downloads</a></li><li><a href="../HB/introduction.html">Handbook</a></li>
            </ul>
        </div>

        <h3 class="collapsible-header collapsed">
            Previous Modules
            <span class="collapse-icon">►</span>
        </h3>
        <div class="collapsible-content collapsed">
            <ul>
            <li><a href="../DH1/introduction.html">DH1</a></li>
            <li><a href="../DH2/introduction.html">DH2</a></li>
            <li><a href="../DH3/introduction.html">DH3</a></li>
        </ul>
        </div>

        <h3>
            <li><a href="./report-issue.html">Report an Issue</a></li>
        </h3>
    </div>
    
    <!-- Sidebar Toggle Button -->
    <button id="sidebar-toggle" class="sidebar-toggle">❮</button>
    
    <!-- Main Content Area -->
    <div id="main-content" class="main-content">
        <!-- Top Navigation Bar -->
        <div class="top-navbar">
            <h1 class="page-title">Data Handling 4</h1>
            <div class="nav-actions">
                <a href="../homepage.html" class="text-button" title="Materials homepage">
                    Homepage
                </a>
                <a href="https://learntodiscover.ai/my-cohorts/" class="text-button" title="Find out more about us">
                    Learn to Discover
                </a>
            </div>
        </div>

        
            <div class="module-card" id="introduction">
                <div class="module-header">
                    Visualisation <span class="module-tag">DH4</span>
                </div>
                <div class="module-body">
                    <h3>Learning Objectives</h3>
                    <div class="learning-outcomes">
                        <div class="outcome-item">
                    <span class="outcome-number">1</span>
                    <span class="outcome-text">How is time series data visualised?</span>
                </div>
<div class="outcome-item">
                    <span class="outcome-number">2</span>
                    <span class="outcome-text">Making a custom plotting function.</span>
                </div>
                    </div>
                    <h3>Introduction</h3>
                    <p>Time series data is unique in that the x-axis is shared (time), however, you do not want to have your individual time series overlapping as this will obscure the data to hand (if you have a lot of time series ). To this extent we will need to extend the use of matplotlib to create data that is offset, rather than overlaid. Creating custom plotting functions is a common task in data analysis and visualisation, and once created you can use them again and again.</p>
                </div>
            </div>
            
            <div class="module-card" id="the-plotting-function">
                <div class="module-body">
                    <div class="module-section">
                        <h3>The Plotting Function</h3>
                        
        <div class="video-container">
            <iframe 
                src="https://www.youtube.com/embed/qWYBBXR8Yrs"
                width="560"
                height="315"
                frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen>
            </iframe>
        </div>
        <p>If you watch the video above you will see the limitations of using Matplotlib in its standard way to plot time series data. To rectify this we have created a plotting function that handles multiple time series data, creating a plot of all the columns in our data, laid out one above the other.<br><br>If you are working locally in a Jupyter Notebook, please execute this cell first to ensure the subsequent code runs without error</p>
        <div class="code-area">
            <div class="code-container code-fixed">
                <textarea id="code-cell-1"># Imports for this lesson
from pandas import read_csv
from numpy import linspace, arange, zeros 
from matplotlib.pyplot import subplots, show, legend</textarea>
            </div>
            <div id="code-cell-1-output" class="output" style="display: none;"></div>
        </div>
        
        <div class="code-area">
            <div class="code-container code-fixed">
                <textarea id="code-cell-2">def plot_series(data, sr):
    &#x27;&#x27;&#x27;
    Time series plot of multiple time series
    Data are normalised to mean=0 and var=1
    
    Parameters:
    -----------
    data : numpy.ndarray
        nxm numpy array. Rows are time points, columns are channels
    sr : int
        Sampling rate, same time units as period
    
    Features:
    ---------
    - Normalises each channel to mean=0, std=1
    - Offsets channels vertically for clear separation
    - Adds reference lines at zero for each channel
    - Proper time axis scaling
    - Channel labelling
    &#x27;&#x27;&#x27;
    # no. of rows or sampling events
    samples = data.shape[0]
    # no. of columns or sensors taking readings
    sensors = data.shape[1]
    # Length of time series in time
    period = samples // sr
    # Array of all time points
    time = linspace(0, period, period*sr)
    
    offset = 5  # for mean=0 and var=1 normalised data
    
    # Calculate means and standard deviations of all columns
    means = data.mean(axis=0)
    stds = data.std(axis=0)
    
    # Plot each series with an offset of 2 times the standard deviations
    fig, ax = subplots(figsize=(7, 8))
    
    # Plot normalised data with vertical offsets
    ax.plot(time, (data - means)/stds + offset*arange(sensors-1, -1, -1))
    
    # Add reference lines at zero for each channel
    ax.plot(time, zeros((samples, sensors)) + offset*arange(sensors-1, -1, -1),
            &#x27;--&#x27;, color=&#x27;gray&#x27;, alpha=0.5)
    
    ax.set(xlabel=&#x27;Time (seconds)&#x27;, ylabel=&#x27;Channel&#x27;)
    ax.set_yticks(offset*arange(sensors))
    ax.set_yticklabels(arange(sensors)[::-1])
    ax.set_title(&#x27;Multi-Channel Time Series Plot&#x27;)
    
    return fig, ax</textarea>
            </div>
            <div id="code-cell-2-output" class="output" style="display: none;"></div>
        </div>
        
        <div class="video-container">
            <iframe 
                src="https://www.youtube.com/embed/T2Qh7yjHC9M"
                width="560"
                height="315"
                frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen>
            </iframe>
        </div>
        
                    </div>
                </div>
            </div>
            
            <div class="module-card" id="normal-and-pathological-eeg">
                <div class="module-body">
                    <div class="module-section">
                        <h3>Normal and Pathological EEG</h3>
                        <p>As an example, let us import two sets of time series data and convert these into NumPy arrays, that we will call <code>data_back</code> and <code>data_epil</code>. They represent a human electroencephalogram (EEG), as recorded during normal background activity and during an epileptic seizure, referred to as an absence seizure.</p><p>The <code>read_csv</code> function is called in combination with the keyword argument <code>sep</code>. When its value is set to <code>&quot;\s+&quot;</code>, this allows the user to import data that are space-separated (rather than comma-separated). If you eyeball the contents of the data .txt files, you will notice that the numbers (which represent voltages) are indeed separated by spaces, not commas. As <code>\</code> is an escape sequence we need to place an <code>r</code> before it to have it treated as a character.<br><br>The data is then converted from a Pandas DataFrame into a NumPy array.<br><br>Next, three constants are assigned: The sampling rate (sr) is given in the number of samples recorded per second; the duration of the recording (period) which is given in seconds; and the number of columns (channels), to be extracted from the recording. Let&#x27;s make use of the first 10 columns of data for the remainder of this lesson.</p>
        <div class="code-area">
            <div class="code-container code-fixed">
                <textarea id="code-cell-3">df_back = read_csv(&quot;./data/EEG_background.txt&quot;, sep=r&quot;\s+&quot;)
df_epil = read_csv(&quot;./data/EEG_absence.txt&quot;, sep=r&quot;\s+&quot;)

d1 = df_back.to_numpy()
d2 = df_epil.to_numpy()

sr = 256      # 1 / seconds
period = 6    # seconds
channels = 10</textarea>
            </div>
            <div id="code-cell-3-output" class="output" style="display: none;"></div>
        </div>
        <p>Now we can filter the NumPy array to only have the first 6 seconds worth of data from the first 10 columns:</p>
        <div class="code-area">
            <div class="code-container code-fixed">
                <textarea id="code-cell-4">data_back = d1[:period*sr:, :channels]
data_epil = d2[:period*sr:, :channels]</textarea>
            </div>
            <div id="code-cell-4-output" class="output" style="display: none;"></div>
        </div>
        <p>To see the names of the channels (or recording sensors), we can use the <code>.head()</code> method, as follows:</p>
        <div class="code-area">
            <div class="code-container code-fixed">
                <textarea id="code-cell-5">df_back.head()</textarea>
            </div>
            <div id="code-cell-5-output" class="output"></div>
        </div>
        <p>Lets also check the shape of both datasets.</p>
        <div class="code-area">
            <div class="code-container code-fixed">
                <textarea id="code-cell-6">print(data_back.shape, data_epil.shape)</textarea>
            </div>
            <div id="code-cell-6-output" class="output"></div>
        </div>
        <p>The row indices and column names for the seizure data look the same. The names of the recording channels are from the commonly used 10-20 system used to record voltages of brain activity from the human scalp. As an example, &#x27;F&#x27; stands for the frontal lobe.<br><br>Next, we can call and make use of the plot function that we defined previously, in order to plot the data. If we examine the code in which this function was defined, you can see that we have set it to require the user to specify two input arguments: these correspond to the dataset (data) and sampling rate (sr).</p>
        <div class="code-area">
            <div class="code-container code-fixed">
                <textarea id="code-cell-7">plot_series(data_back, sr)

show()</textarea>
            </div>
            <div id="code-cell-7-output" class="output"></div>
        </div>
        
        <div class="code-area">
            <div class="code-container code-fixed">
                <textarea id="code-cell-8">plot_series(data_epil, sr)

show()</textarea>
            </div>
            <div id="code-cell-8-output" class="output"></div>
        </div>
        
                    </div>
                </div>
            </div>
            
            <div class="module-card" id="display-data-with-offset">
                <div class="module-body">
                    <div class="module-section">
                        <h3>Display data with offset</h3>
                        <p>Scroll up, and take a look at the code we gave previously, that defines the function <code>plot_series</code>. Again, this is the function we are using to create our time series plot. It requires the input of a data file where the row index is interpreted as time. In addition, the sampling rate (sr) is required in order to extract the time scale. The sampling rate specifies the number of samples recorded per unit time.<br><br>The sensors, or recording channels, are assumed to be in the columns.<br><br>The declaration syntax <code>def</code> is followed by the function name and, in parentheses, the input arguments. This line ends with a colon, which is required by Python in order to define the start of a block of code.<br><br>Following the declaration line, the function&#x27;s documentation or docstring is contained within two lines of triple backticks. This explains the function&#x27;s operation, arguments and use – and can contain any other useful information pertaining to the operation of the defined function.<br><br>Following the docstring, the main lines of code that operate on the arguments provided by the user, when the function is called.<br><br>The function can then be closed using the optional output syntax <code>return</code> and any number of returned variables, anything that might be used as a product of running the function.<br><br>In our example, the figure environment and the coordinate system are &#x27;returned&#x27; and can, in principle, be used to further modify the plot.<br><br>The code below illustrates how to call the function and then add a title and the sensor names to the displayed output:</p>
        <div class="code-area">
            <div class="code-container code-fixed">
                <textarea id="code-cell-9">(fig, ax) = plot_series(data_epil, sr)

names = df_back.columns[:channels]

fig.suptitle(&#x27;Recording of Absence Seizure&#x27;, fontsize=16)
legend(names)

show()</textarea>
            </div>
            <div id="code-cell-9-output" class="output"></div>
        </div>
        <p>The variables passed into a function are called its <strong>input arguments</strong>; and the values it returns are termed its <strong>outputs</strong>. A function ordinarily accepts data or variables in the form of one or several such input arguments, processes these, and subsequently produces a specific output.</p><p>A reminder of some of the key points about functions from Python Fundamentals:<ul class="nested-list"><li>The name of a function follows same principles as that of any other variable. It must be in lower-case characters, and it is strongly suggested that its name bears resemblance to the processes it undertakes.</li><br><li>The input arguments of a function, e.g. <code>data</code> and <code>sr</code> in our example, are essentially variables whose scope is confined only to the function. That is, they are only accessible within the function itself, and not from outside the function.</li><br><li>Variables defined inside of a function should not use the same name as variables defined outside. Otherwise they may override each other.</li><br><li>When defining a function, it is important and best practice to write that function to perform only one specific task. As such, it can be used independent of the current context. Try to avoid incorporating separable tasks into a single function.</li><br><li>Once you start creating functions for different purposes you can start to build your own library of ready-to-use functions. This is the primary principle of a popular programming paradigm known as functional programming.</li></ul></p>
                    </div>
                </div>
            </div>
            
            <div class="module-card" id="summary">
                <div class="module-body">
                    <div class="module-section">
                        <h3>Summary</h3>
                        <p>By learning to create custom plotting functions that normalise and vertically offset multi-channel time series data, we can effectively visualize complex physiological recordings where standard plotting approaches fall short. Understanding how to structure functions with clear input arguments, proper documentation and reusable outputs enables the development of a personal library of analytical tools tailored to specific research needs. This approach transforms overlapping, difficult-to-interpret traces into clear, separated channels that reveal patterns in datasets such as EEG recordings. Mastering these visualisation techniques facilitates rapid identification of pathological events, comparison across conditions and efficient exploration of large multi-sensor datasets.</p>
                    </div>
                </div>
            </div>
            
        
        <div class="page-navigation">
            <a href="./introduction.html" class="nav-button prev">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
                </svg>
                Previous
            </a>
            <a href="./filtering.html" class="nav-button next">
                Next
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
                </svg>
            </a></div>
        
        <!-- Footer -->
        <div class="footer">
            <div>© All materials are copyright scryptIQ 2025</div>
            <div>Powered by Pyodide</div>
        </div>
    </div>

    <!-- JavaScript -->
    <script src="../assets/main.js"></script>
    
    <!-- Pyodide Initialisation Script -->
    <script>

// Generalisable Pyodide Initialisation Script
// Variables and state build up naturally as code blocks execute in order

async function main() {
    // Show loading message for all output elements
    document.querySelectorAll(".output").forEach(el => {
        el.textContent = "Loading Pyodide...";
        el.classList.add("loading-message");
    });
    
    try {
        // Load Pyodide
        console.log("Loading Pyodide...");
        const pyodideStartTime = performance.now();
        let pyodide = await loadPyodide();
        const pyodideLoadTime = performance.now() - pyodideStartTime;
        console.log(`Pyodide loaded in ${pyodideLoadTime.toFixed(2)}ms`);
        
        // Load required packages only if specified
        const lessonPackages = window.LESSON_PACKAGES || [];
        
        if (lessonPackages.length > 0) {
            console.log("Loading required Python packages...");
            const packagesStartTime = performance.now();
            
            // Separate built-in packages from PyPI packages
            const builtInPackages = lessonPackages.filter(pkg => 
                ['numpy', 'scipy', 'matplotlib', 'pandas', 'scikit-learn', 'pillow', 'regex'].includes(pkg)
            );
            
            const micropipPackages = lessonPackages.filter(pkg => !builtInPackages.includes(pkg));
            
            // Load built-in packages (fast)
            if (builtInPackages.length > 0) {
                await pyodide.loadPackage(builtInPackages);
                console.log(`Loaded built-in packages: ${builtInPackages.join(', ')}`);
            }
            
            // Install PyPI packages (slower)
            if (micropipPackages.length > 0) {
                await pyodide.loadPackage(['micropip']);
                const micropip = pyodide.pyimport('micropip');
                await micropip.install(micropipPackages);
                console.log(`Installed PyPI packages: ${micropipPackages.join(', ')}`);
            }
            
            const packagesLoadTime = performance.now() - packagesStartTime;
            console.log(`Packages loaded in ${packagesLoadTime.toFixed(2)}ms`);
            console.log(`Total initialisation time: ${(pyodideLoadTime + packagesLoadTime).toFixed(2)}ms`);
        } else {
            console.log("No packages to load for this lesson");
            console.log(`Total initialisation time: ${pyodideLoadTime.toFixed(2)}ms`);
        }

        // Only set up basic Python environment - no pre-loaded variables
        await pyodide.runPythonAsync(`
            import sys
            from io import StringIO
        `);

        // Only set up matplotlib if it's in the loaded packages
        if (lessonPackages.includes('matplotlib')) {
            await pyodide.runPythonAsync(`
                # Set up matplotlib for web rendering
                import matplotlib
                matplotlib.use('AGG')
                import matplotlib.pyplot as plt
                import io
                import base64
                
                def capture_matplotlib():
                    """Capture current matplotlib figure as HTML img tag"""
                    buf = io.BytesIO()
                    plt.savefig(buf, format='png', bbox_inches='tight', dpi=100)
                    buf.seek(0)
                    img_base64 = base64.b64encode(buf.read()).decode('utf-8')
                    plt.close()
                    return f'<img src="data:image/png;base64,{img_base64}" style="max-width: 100%; height: auto;" />'
            `);
            console.log('Matplotlib capture function set up');
        }
        
        console.log("Pyodide loaded successfully");
        
        // Load remote files if URLs are specified
        const lessonFiles = window.LESSON_FILES || [];
        
        if (lessonFiles.length > 0) {
            try {
                console.log(`Checking for ${lessonFiles.length} remote file(s) to load...`);
                
                // Build Python code to load all files dynamically
                let pythonCode = `
from pyodide.http import pyfetch
import os

# Create data directory if it doesn't exist
os.makedirs('./data', exist_ok=True)
`;
                
                // Add loading code for each file
                for (const file of lessonFiles) {
                    if (file.is_binary) {
                        // Binary files (images, etc.) - use bytes
                        pythonCode += `
# Load ${file.filename} (binary)
try:
    response = await pyfetch("${file.url}")
    content = await response.bytes()
    with open('./data/${file.filename}', 'wb') as f:
        f.write(bytes(content))
    print("Loaded: ${file.filename}")
except Exception as e:
    print(f"Could not load ${file.filename}: {e}")
`;
                    } else {
                        // Text files (CSV, etc.) - use string
                        pythonCode += `
# Load ${file.filename} (text)
try:
    response = await pyfetch("${file.url}")
    content = await response.string()
    with open('./data/${file.filename}', 'w') as f:
        f.write(content)
    print("Loaded: ${file.filename}")
except Exception as e:
    print(f"Could not load ${file.filename}: {e}")
`;
                    }
                }
                
                await pyodide.runPythonAsync(pythonCode);
                console.log("Remote files loaded successfully");
            } catch (error) {
                console.warn("Error loading remote files (continuing anyway):", error);
            }
        } else {
            console.log("No remote files to load for this lesson");
        }
        
        // Function to execute Python code and capture output
        async function executePythonCode(code) {
            try {
                // Redirect Python stdout to capture print statements
                await pyodide.runPythonAsync(`
                    old_stdout = sys.stdout
                    sys.stdout = mystdout = StringIO()
                `);
                
                // Run the user code
                const result = await pyodide.runPythonAsync(code);
                
                // Get the captured stdout
                let stdout = await pyodide.runPythonAsync(`
                    sys.stdout = old_stdout
                    mystdout.getvalue()
                `);
                
                // Check for matplotlib figures only if matplotlib was loaded
                const lessonPackages = window.LESSON_PACKAGES || [];
                if (lessonPackages.includes('matplotlib')) {
                    const hasFigures = await pyodide.runPythonAsync(`
                        import matplotlib.pyplot as plt
                        len(plt.get_fignums()) > 0
                    `);
                    
                    if (hasFigures) {
                        const figureHtml = await pyodide.runPythonAsync(`capture_matplotlib()`);
                        if (stdout) stdout += "\n";
                        stdout += figureHtml;
                    }
                }
                
                // Combine stdout and result
                let output = stdout;
                if (result !== undefined && result !== null && String(result).trim() !== '') {
                    if (output) output += "\n";
                    output += String(result);
                }
                
                return { success: true, output: output || "Code executed successfully (no output)" };
                
            } catch (error) {
                return { success: false, output: "Error: " + error.message };
            }
        }
        
        // Execute all hidden code blocks first (for setup code like imports)
        const hiddenCodeBlocks = Array.from(document.querySelectorAll('.hidden-code textarea'));
        console.log(`Found ${hiddenCodeBlocks.length} hidden code blocks`);

        for (const textarea of hiddenCodeBlocks) {
            const code = textarea.value.trim();
            if (!code) continue;
            
            console.log(`Executing hidden code block: ${textarea.id}`);
            console.log(`Hidden code content: ${code.substring(0, 100)}...`);
            const result = await executePythonCode(code);
            
            if (!result.success) {
                console.error(`Error in hidden code block ${textarea.id}:`, result.output);
            } else {
                console.log(`Hidden code block ${textarea.id} executed successfully`);
                console.log(`Result: ${result.output}`);
            }
        }

        console.log("All hidden code blocks executed");
        
        // Get all fixed code blocks in document order
        const fixedCodeBlocks = Array.from(document.querySelectorAll('.code-fixed textarea'));
        
        // Setup and execute fixed code blocks sequentially
        for (const textarea of fixedCodeBlocks) {
            const code = textarea.value.trim();
            if (!code) continue;
            
            // Set up CodeMirror editor (read-only)
            const editor = CodeMirror.fromTextArea(textarea, {
                mode: "python",
                theme: "pastel-on-dark",
                lineNumbers: true,
                readOnly: true,
                viewportMargin: Infinity
            });
            
            // Find corresponding output element
            const outputId = textarea.id + '-output';
            const outputElement = document.getElementById(outputId);
            
            if (outputElement) {
                outputElement.textContent = "Running code...";
                outputElement.classList.add("loading-message");
                
                // Execute the code (this maintains state for subsequent blocks)
                const result = await executePythonCode(code);
                
                // Display the output - check if it's HTML
                const trimmedOutput = result.output.trim();
                console.log('Output length:', trimmedOutput.length);
                console.log('Output starts with:', trimmedOutput.substring(0, 100));
                
                if (trimmedOutput.includes('<script') && trimmedOutput.includes('Plotly')) {
                    // It's Plotly HTML output - extract just the body content
                    console.log('Rendering as Plotly HTML');
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(result.output, 'text/html');
                    // Clear the output element and append the body content
                    outputElement.innerHTML = '';
                    
                    // Find and load external scripts first (like Plotly CDN)
                    const externalScripts = Array.from(doc.querySelectorAll('script[src]'));
                    const inlineScripts = Array.from(doc.querySelectorAll('script:not([src])'));
                    
                    // Append non-script content first
                    Array.from(doc.body.children).forEach(child => {
                        if (child.tagName !== 'SCRIPT') {
                            outputElement.appendChild(child.cloneNode(true));
                        }
                    });
                    
                    // Load external scripts sequentially
                    const loadScript = (src) => {
                        return new Promise((resolve, reject) => {
                            const script = document.createElement('script');
                            script.src = src;
                            script.onload = resolve;
                            script.onerror = reject;
                            document.head.appendChild(script);
                        });
                    };
                    
                    // Load all external scripts first
                    Promise.all(externalScripts.map(s => loadScript(s.src)))
                        .then(() => {
                            console.log('External scripts loaded, executing inline scripts');
                            // Now execute inline scripts
                            inlineScripts.forEach(oldScript => {
                                const newScript = document.createElement('script');
                                newScript.textContent = oldScript.textContent;
                                outputElement.appendChild(newScript);
                            });
                            console.log('Output element after processing:', outputElement.children.length, 'children');
                        })
                        .catch(err => {
                            console.error('Failed to load external scripts:', err);
                            outputElement.textContent = 'Error loading Plotly: ' + err.message;
                        });
                } else if (trimmedOutput.startsWith('<!DOCTYPE') || 
                           trimmedOutput.startsWith('<html') ||
                            trimmedOutput.startsWith('<div') ||
                            trimmedOutput.startsWith('<img')) {
                    console.log('Rendering as generic HTML');
                    outputElement.innerHTML = result.output;
                    console.log('Output element after innerHTML:', outputElement.children.length, 'children');
                } else {
                    console.log('Rendering as plain text');
                    outputElement.textContent = result.output;
                }
                outputElement.classList.remove("loading-message");
                if (result.success) {
                    outputElement.classList.add("success-message");
                    outputElement.classList.remove("error-message");
                } else {
                    outputElement.classList.add("error-message");
                    outputElement.classList.remove("success-message");
                }
            }
            
            // Small delay to show progression
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Set flag to indicate all FIXED cells have been executed
        // This is used by PDF generation to ensure all outputs are ready
        window.allCellsExecuted = true;
        console.log("All FIXED cells executed successfully");
        
        // Setup all editable code blocks (but don't execute them)
        document.querySelectorAll('.code-editor textarea').forEach((textarea) => {
            // Set up CodeMirror editor (editable)
            const editor = CodeMirror.fromTextArea(textarea, {
                mode: "python",
                theme: "pastel-on-dark",
                lineNumbers: true,
                viewportMargin: Infinity
            });
            
            // Find corresponding run button and output element
            const baseId = textarea.id;
            const runButtonId = 'run-' + baseId;
            const outputId = baseId + '-output';
            
            const runButton = document.getElementById(runButtonId);
            const outputElement = document.getElementById(outputId);
            
            if (runButton && outputElement) {
                // Set initial state
                outputElement.textContent = "Ready to run code!";
                outputElement.classList.remove("loading-message");
                
                runButton.addEventListener("click", async () => {
                    const code = editor.getValue().trim();
                    if (!code) {
                        outputElement.textContent = "No code to run";
                        return;
                    }
                    
                    outputElement.textContent = "Running...";
                    outputElement.classList.remove("error-message", "success-message");
                    outputElement.classList.add("loading-message");
                    
                    // Execute the code (this also maintains state for future blocks)
                    const result = await executePythonCode(code);
                    
                    // Display the output - check if it's HTML
                    const trimmedOutput = result.output.trim();
                    console.log('Output length:', trimmedOutput.length);
                    console.log('Output starts with:', trimmedOutput.substring(0, 100));
                    
                    if (trimmedOutput.includes('<script') && trimmedOutput.includes('Plotly')) {
                        // It's Plotly HTML output - extract just the body content
                        console.log('Rendering as Plotly HTML');
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(result.output, 'text/html');
                        // Clear the output element and append the body content
                        outputElement.innerHTML = '';
                        
                        // Find and load external scripts first (like Plotly CDN)
                        const externalScripts = Array.from(doc.querySelectorAll('script[src]'));
                        const inlineScripts = Array.from(doc.querySelectorAll('script:not([src])'));
                        
                        // Append non-script content first
                        Array.from(doc.body.children).forEach(child => {
                            if (child.tagName !== 'SCRIPT') {
                                outputElement.appendChild(child.cloneNode(true));
                            }
                        });
                        
                        // Load external scripts sequentially
                        const loadScript = (src) => {
                            return new Promise((resolve, reject) => {
                                const script = document.createElement('script');
                                script.src = src;
                                script.onload = resolve;
                                script.onerror = reject;
                                document.head.appendChild(script);
                            });
                        };
                        
                        // Load all external scripts first
                        Promise.all(externalScripts.map(s => loadScript(s.src)))
                            .then(() => {
                                console.log('External scripts loaded, executing inline scripts');
                                // Now execute inline scripts
                                inlineScripts.forEach(oldScript => {
                                    const newScript = document.createElement('script');
                                    newScript.textContent = oldScript.textContent;
                                    outputElement.appendChild(newScript);
                                });
                                console.log('Output element after processing:', outputElement.children.length, 'children');
                            })
                            .catch(err => {
                                console.error('Failed to load external scripts:', err);
                                outputElement.textContent = 'Error loading Plotly: ' + err.message;
                            });
                    } else if (trimmedOutput.startsWith('<!DOCTYPE') || 
                               trimmedOutput.startsWith('<html') ||
                               trimmedOutput.startsWith('<div') ||
                               trimmedOutput.startsWith('<img')) {
                        outputElement.innerHTML = result.output;
                    } else {
                        outputElement.textContent = result.output;
                    }
                    outputElement.classList.remove("loading-message");
                    if (result.success) {
                        outputElement.classList.add("success-message");
                        outputElement.classList.remove("error-message");
                    } else {
                        outputElement.classList.add("error-message");
                        outputElement.classList.remove("success-message");
                    }
                });
            }
        });
        
        console.log("All code blocks initialised successfully");

        // Set flag to indicate Pyodide is fully ready
        window.pyodideReady = true;
        console.log("Pyodide fully ready");
        
    } catch (error) {
        console.error("Failed to initialise Pyodide:", error);
        document.querySelectorAll(".output").forEach(el => {
            el.textContent = "Error loading Pyodide: " + error.message;
            el.classList.remove("loading-message");
            el.classList.add("error-message");
        });
    }
}

// Start the application when DOM is loaded
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', main);
} else {
    main();
}
    </script>
</body>
</html>
    